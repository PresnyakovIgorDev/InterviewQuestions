**Monitor**

Наряду с оператором lock для синхронизации потоков мы можем использовать мониторы, представленные классом System.Threading.Monitor. Фактически конструкция оператора lock инкапсулирует в себе синтаксис использования мониторов

```c#
    public static void Count()
    {
        try
        {
            Monitor.Enter(locker);
            x = 1;
            for (int i = 1; i < 9; i++)
            {
                Console.WriteLine("{0}: {1}", Thread.CurrentThread.Name, x);
                x++;
                Thread.Sleep(100);
            }
        }
        finally
        {
            Monitor.Exit(locker);
        }
    }
```

Метод `Monitor.Enter` блокирует объект locker так же, как это делает оператор lock. А в блоке try...finally с помощью 
метода `Monitor.Exit` происходит освобождение объекта locker, и он становится доступным для других потоков.



Кроме блокировки и разблокировки объекта класс Monitor имеет еще ряд 
методов, которые позволяют управлять синхронизацией потоков. 
Так, метод `Monitor.Wait` освобождает блокировку объекта и 
переводит поток в очередь ожидания объекта. 
Следующий поток в очереди готовности объекта блокирует данный объект. А 
все потоки, которые вызвали метод Wait, остаются в очереди 
ожидания, пока не получат сигнала от метода `Monitor.Pulse` или `Monitor.PulseAll`, посланного владельцем 
блокировки. Если метод `Monitor.Pulse` отправлен, поток, находящийся во главе очереди ожидания, получает сигнал и блокирует освободившийся объект. 
Если же метод `Monitor.PulseAll` отправлен, то все потоки, находящиеся в очереди ожидания, получают сигнал и переходят в очередь
готовности, где им снова разрешается получать блокировку объекта.

